package Analizador;
import java_cup.runtime.Symbol;
import Aplicacion.Errores;
import Aplicacion.Conjunto;
import Aplicacion.NodoT;
import Aplicacion.Thompson;
import java.util.ArrayList;
import java.util.Collections;
parser code {:

    
    public ArrayList<Errores> a = new ArrayList<>();
    public ArrayList<Conjunto> con = new ArrayList<>();
    public ArrayList<Thompson> tom = new ArrayList<>();
    public ArrayList<String> car = new ArrayList<>();

    /*Method that is called when parser can be recovered*/
	public void syntax_error(Symbol s){
        System.out.println("Este es un error de sintaxis: "+s.value + ". Localizado en Fila " + (s.right+1) +" y Columna "+(s.left+1));
        Errores crear = new Errores("Error sintaxix", s.value.toString(), s.right+1, s.left+1);
        a.add(crear);
    }

	/*Method that is called when parser can't be recovered*/
	public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception{
        System.out.println("Este es un error de sintaxis: "+s.value + ". Localizado en Fila "+ (s.right+1) +" y Columna "+(s.left+1) + ". No se pudo recuperar.");
        Errores crear = new Errores("Error sintaxix", s.value.toString(), s.right+1, s.left+1);
        a.add(crear);

    }

:}

terminal String porcentaje, conjunto, concatenacion, or, kleene, positiva, cerouno, guion, cierre, apertura, coma, dospuntos, puntocoma;
terminal String cadena, digito, letra, simbolo, flecha, id, especial;

non terminal SO, CONTENIDO, DECLARACION, VALIDAR, CONJUNTO, EXPRESION;
non terminal ArrayList<Object> OTROS, E;
non terminal String BINARIO, UNARIO, NOT, GRUPO, VAL, SYM;


start with SO;

/*--------------- Manejo de Declaraciones -----------------------*/
SO ::= apertura CONTENIDO cierre
;

CONTENIDO ::= DECLARACION porcentaje porcentaje porcentaje porcentaje VALIDAR
;

DECLARACION ::= CONJUNTO DECLARACION
                |EXPRESION DECLARACION
                |CONJUNTO
                |EXPRESION
;

/*--------------- Manejo de Conjuntos -----------------------*/

CONJUNTO ::= conjunto dospuntos id:a flecha NOT:b puntocoma
            {:
                ArrayList<String> ncar = new ArrayList<>();
                for(int i = 0; i < car.size(); i++){
                    ncar.add(car.get(i));
                }
                Conjunto nuevo = new Conjunto(a, ncar, b);
                con.add(nuevo);
                car.clear();
            :}
;

NOT ::= letra:a guion letra:b
        {:
            int min = a.toCharArray()[0];
            int max = b.toCharArray()[0];
            if(min > max){
                int ntem = min;
                min = max;
                max = ntem;
            }
            for(int i=min;i<=max;i++){
                car.add(Character.toString(i));
            }
            String temp = "[" + a + "-" + b +"]";            
            RESULT = temp;
        :}

        |digito:a guion digito:b
        {:
            int min = a.toCharArray()[0];
            int max = b.toCharArray()[0];
            if(min > max){
                int ntem = min;
                min = max;
                max = ntem;
            }
            for(int i=min;i<=max;i++){
                car.add(Character.toString(i));
            }
            String temp = "[" + a + "-" + b +"]";            
            RESULT = temp;
        :}

        |SYM:a guion SYM:b
        {:
            int min = a.toCharArray()[0];
            int max = b.toCharArray()[0];
            if(min > max){
                int ntem = min;
                min = max;
                max = ntem;
            }
            for(int i=min;i<=max;i++){
                car.add(Character.toString(i));
            }
            String temp = "[" + a + "-" + b +"]";            
            RESULT = temp;
        :}

        |GRUPO:a
        {:
            String temp = "(" + a + ")";   
            Collections.reverse(car);
            RESULT = temp;
        :}
;

VAL ::= letra:a             {: RESULT = a; :}
        |digito:a           {: RESULT = a; :}
        |SYM:a              {: RESULT = a; :}
;

SYM ::= simbolo:a               {: RESULT = a; :}
        |porcentaje:a           {: RESULT = a; :}
        |concatenacion:a        {: RESULT = a; :}
        |or:a                   {: RESULT = a; :}
        |kleene:a               {: RESULT = a; :}
        |positiva:a             {: RESULT = a; :}
        |cerouno:a              {: RESULT = a; :}
;

GRUPO ::= VAL:a coma GRUPO:b
          {:
            String not = a + "|" + b;
            car.add(a);
            RESULT = not;
          :}


          |VAL:a
          {:
            car.add(a);
            RESULT = a;
          :}
;

/*--------------- Manejo de Expresiones -----------------------*/
EXPRESION ::= id:a flecha E:b puntocoma
         {:
            //Procedimiento del metodo Thompson
            NodoT Cabecera1 = (NodoT)b.get(0);
            NodoT Salida1 = (NodoT)b.get(1);
            ArrayList<NodoT> a1 = (ArrayList<NodoT>)b.get(2);
            Thompson nuevo = new Thompson(a, a1, Cabecera1);
            tom.add(nuevo);
            
            //Procedimiento del metodo del arbol
            
         :}
;

E ::= BINARIO:a E:b E:c
      {:
        if(a.equals(".")){                                           //Concatenación
            ArrayList<Object> temp = new ArrayList<>();
        //Procedimiento para el método Thompson
            NodoT Cabecera1 = (NodoT)b.get(0);
            NodoT Salida1 = (NodoT)b.get(1);
            ArrayList<NodoT> a1 = (ArrayList<NodoT>)b.get(2);

            NodoT Cabecera2 = (NodoT)c.get(0);
            NodoT Salida2 = (NodoT)c.get(1);
            ArrayList<NodoT> a2 = (ArrayList<NodoT>)c.get(2);
            
            //Procedimiento
            //1.Convertir salida en nueva entrada
            if(Cabecera2.next1 != null){
                Salida1.next1 = Cabecera2.next1;
                Salida1.tran1 = Cabecera2.tran1;
            }
            
            if(Cabecera2.next2 != null){
                Salida1.next2 = Cabecera2.next2;
                Salida1.tran2 = Cabecera2.tran2;
            }
            
            //2. Borrar nodo reemplazado
            a2.remove(0);
            Cabecera2 = null;
            
            //3. Preparar Info
            NodoT Cabecera = Cabecera1;
            NodoT Salida = Salida2;
            ArrayList<NodoT>ListaNombre = new ArrayList<>();
            for(int i = 0; i < a1.size(); i++){
                ListaNombre.add(a1.get(i));
            }
            for(int i = 0; i < a2.size(); i++){
                ListaNombre.add(a2.get(i));
            }
            temp.add(Cabecera);
            temp.add(Salida);
            temp.add(ListaNombre);

            //Procedimiento para metodo del arbol
            RESULT = temp;
            
        }else{                                                      //Or
            ArrayList<Object> temp = new ArrayList<>();
        //Procedimiento para el método Thompson
            NodoT Cabecera1 = (NodoT)b.get(0);
            NodoT Salida1 = (NodoT)b.get(1);
            ArrayList<NodoT> a1 = (ArrayList<NodoT>)b.get(2);

            NodoT Cabecera2 = (NodoT)c.get(0);
            NodoT Salida2 = (NodoT)c.get(1);
            ArrayList<NodoT> a2 = (ArrayList<NodoT>)c.get(2);
            
            //Procedimiento
            NodoT t1 = new NodoT();
            NodoT t2 = new NodoT();
            t1.next1 = Cabecera1;
            t1.tran1 = "\"" + "*E*" + "\"";
            t1.next2 = Cabecera2;
            t1.tran2 = "\"" + "*E*" + "\"";

            Salida1.next1 = t2;
            Salida1.tran1 = "\"" + "*E*" + "\"";
            Salida2.next2 = t2;
            Salida2.tran2 = "\"" + "*E*" + "\"";
            
            //Preparar Info
            NodoT Cabecera = t1;
            NodoT Salida = t2;
            ArrayList<NodoT>ListaNombre = new ArrayList<>();
            ListaNombre.add(Cabecera);
            for(int i = 0; i < a1.size(); i++){
                ListaNombre.add(a1.get(i));
            }
            for(int i = 0; i < a2.size(); i++){
                ListaNombre.add(a2.get(i));
            }
            ListaNombre.add(Salida);
            temp.add(Cabecera);
            temp.add(Salida);
            temp.add(ListaNombre);

            //Procedimiento para metodo del arbol
            RESULT = temp;
        }
      :}

      |UNARIO:a E:b
      {:
        if(a.equals("*")){                                           //Kleene
            ArrayList<Object> temp = new ArrayList<>();
        //Procedimiento para el método Thompson
            NodoT Cabecera1 = (NodoT)b.get(0);
            NodoT Salida1 = (NodoT)b.get(1);
            ArrayList<NodoT> a1 = (ArrayList<NodoT>)b.get(2);

            //Procedimiento
            NodoT t1 = new NodoT();
            NodoT t2 = new NodoT();
            t1.next1 = Cabecera1;
            t1.tran1 = "\"" + "*E*" + "\"";
            t1.next2 = t2;
            t1.tran2 = "\"" + "*E*" + "\"";
            t1.constraint = true;

            Salida1.next1 = t2;
            Salida1.tran1 = "\"" + "*E*" + "\"";
            Salida1.next2 = Cabecera1;
            Salida1.tran2 = "\"" + "*E*" + "\"";
            
            //Preparar Info
            NodoT Cabecera = t1;
            NodoT Salida = t2;
            ArrayList<NodoT>ListaNombre = new ArrayList<>();
            ListaNombre.add(Cabecera);
            for(int i = 0; i < a1.size(); i++){
                ListaNombre.add(a1.get(i));
            }
            ListaNombre.add(Salida);
            temp.add(Cabecera);
            temp.add(Salida);
            temp.add(ListaNombre);

            //Procedimiento para metodo del arbol
            RESULT = temp;
            
        }else{
            if(a.equals("+")){                                           //Positiva
                ArrayList<Object> temp = new ArrayList<>();
            //Procedimiento para el método Thompson
                NodoT Cabecera1 = (NodoT)b.get(0);
                NodoT Salida1 = (NodoT)b.get(1);
                ArrayList<NodoT> a1 = (ArrayList<NodoT>)b.get(2);

                //Procedimiento
                //1. Clonar entrada
                ArrayList<String> ctran = new ArrayList<>();
                ArrayList<NodoT> clon = new ArrayList<>();

                for(int i = 0; i < a1.size(); i++){
                    //Renombrar nodos
                    NodoT rlis = a1.get(i);
                    rlis.Nombre = Character.toString(41 + i);
                }

                for(int i = 0; i < a1.size(); i++){
                    //Creacion de Nodos
                    NodoT tclon = new NodoT();
                    tclon.Nombre = Character.toString(41 + i); 
                    clon.add(tclon);
                    
                    //Adicion de Trancisiones a la lista de strings
                    NodoT rlis = a1.get(i);
                    
                    if(rlis.next1 != null){
                        ctran.add(Character.toString(41 + i));
                        ctran.add(rlis.next1.Nombre);
                        ctran.add(rlis.tran1);
                    }

                    if(rlis.next2 != null){
                        ctran.add(Character.toString(41 + i));
                        ctran.add(rlis.next2.Nombre);
                        ctran.add(rlis.tran2);
                    }
                }
                
                for(int i = 0; i < (ctran.size()/3); i++){
                    String A = ctran.get(i*3);
                    String B = ctran.get((i*3)+1);
                    String C = ctran.get((i*3)+2);
                    
                    NodoT A1 = new NodoT();
                    for(int j = 0; j < clon.size(); j++){
                        A1 = clon.get(j);
                        if(A1.Nombre.equals(A)){
                            break;
                        }
                    }
                    
                    NodoT B1 = new NodoT();
                    for(int j = 0; j < clon.size(); j++){
                        B1 = clon.get(j);
                        if(B1.Nombre.equals(B)){
                            break;
                        }
                    }
                    
                    if(A1.next1 == null){
                        A1.next1 = B1;
                        A1.tran1 = C;
                    }else{
                        A1.next2 = B1;
                        A1.tran2 = C;
                    }
                }
                
                NodoT Cabecera2 = clon.get(0);
                NodoT Salida2 = clon.get(clon.size()-1);
                ArrayList<NodoT> a2 = clon;
                
                //2.Kleene
                NodoT t1 = new NodoT();
                NodoT t2 = new NodoT();
                t1.next1 = Cabecera2;
                t1.tran1 = "\"" + "*E*" + "\"";
                t1.next2 = t2;
                t1.tran2 = "\"" + "*E*" + "\"";

                Salida2.next1 = t2;
                Salida2.tran1 = "\"" + "*E*" + "\"";
                Salida2.next2 = Cabecera2;
                Salida2.tran2 = "\"" + "*E*" + "\"";
                
                NodoT CabeceraClon = t1;
                NodoT SalidaClon = t2;
                ArrayList<NodoT>ListaNombreClon = new ArrayList<>();
                ListaNombreClon.add(CabeceraClon);
                for(int i = 0; i < clon.size(); i++){
                    ListaNombreClon.add(clon.get(i));
                }
                ListaNombreClon.add(SalidaClon);
                
                //3. Concatenación
                if(CabeceraClon.next1 != null){
                    Salida1.next1 = CabeceraClon.next1;
                    Salida1.tran1 = CabeceraClon.tran1;
                }

                if(CabeceraClon.next2 != null){
                    Salida1.next2 = CabeceraClon.next2;
                    Salida1.tran2 = CabeceraClon.tran2;
                }

                //Borrar nodo reemplazado
                ListaNombreClon.remove(0);
                CabeceraClon = null;


                //3. Preparar Info
                NodoT Cabecera = Cabecera1;
                NodoT Salida = SalidaClon;
                ArrayList<NodoT>ListaNombre = new ArrayList<>();
                for(int i = 0; i < a1.size(); i++){
                    ListaNombre.add(a1.get(i));
                }
                for(int i = 0; i < ListaNombreClon.size(); i++){
                    ListaNombre.add(ListaNombreClon.get(i));
                }
                temp.add(Cabecera);
                temp.add(Salida);
                temp.add(ListaNombre);

                //Procedimiento para metodo del arbol
                RESULT = temp;
            
            }else{                                         //Uno o Cero
                ArrayList<Object> temp = new ArrayList<>();
            //Procedimiento para el método Thompson
                NodoT Cabecera1 = (NodoT)b.get(0);
                NodoT Salida1 = (NodoT)b.get(1);
                ArrayList<NodoT> a1 = (ArrayList<NodoT>)b.get(2);

                //Procedimiento
                NodoT t1 = new NodoT();
                NodoT t2 = new NodoT();
                NodoT te = new NodoT();
                NodoT ts = new NodoT();
                te.next1 = Cabecera1;
                te.tran1 = "\"" + "*E*" + "\"";
                te.next2 = t1;
                te.tran2 = "\"" + "*E*" + "\"";

                t1.next1 = t2;
                t1.tran2 = "\"" + "*E*" + "\"";
                t2.next1 = ts;
                t2.tran1 = "\"" + "*E*" + "\"";
                Salida1.next2 = ts;
                Salida1.tran2 = "\"" + "*E*" + "\"";

                //Preparar Info
                NodoT Cabecera = te;
                NodoT Salida = ts;
                ArrayList<NodoT>ListaNombre = new ArrayList<>();
                ListaNombre.add(Cabecera);
                for(int i = 0; i < a1.size(); i++){
                    ListaNombre.add(a1.get(i));
                }
                ListaNombre.add(t1);
                ListaNombre.add(t2);
                ListaNombre.add(Salida);
                temp.add(Cabecera);
                temp.add(Salida);
                temp.add(ListaNombre);

                //Procedimiento para metodo del arbol
                RESULT = temp;
            }
        }
      :}

      |apertura id:a cierre
      {:
        Conjunto ct = null;
        int ban = 0;
        for(int i = 0; i < con.size(); i++){
            ct = con.get(i);
            if(ct.ID.equals(a)){
                ban = 1;
                break;
            }
        }
        
        if(ban == 1){
            //Procedimiento para el método Thompson
            NodoT t1 = new NodoT();
            NodoT t2 = new NodoT();
            t1.next1 = t2;
            t1.tran1 = "\"" +ct.notacion + "\"";
            
            NodoT Cabecera = t1;
            NodoT Salida = t2;
            ArrayList<NodoT>ListaNombre = new ArrayList<>();
            ListaNombre.add(t1);
            ListaNombre.add(t2);
            ArrayList<Object> temp = new ArrayList<>();
            temp.add(Cabecera);
            temp.add(Salida);
            temp.add(ListaNombre);
            
            //Procedimiento para el metodo del arbol
            RESULT = temp;
        }else{
            //Procedimiento para el método Thompson
            NodoT t1 = new NodoT();
            NodoT t2 = new NodoT();
            t1.next1 = t2;
            t1.tran1 = "\""+ "Error" + "\"";
            
            NodoT Cabecera = t1;
            NodoT Salida = t2;
            ArrayList<NodoT>ListaNombre = new ArrayList<>();
            ListaNombre.add(t1);
            ListaNombre.add(t2);
            ArrayList<Object> temp = new ArrayList<>();
            temp.add(Cabecera);
            temp.add(Salida);
            temp.add(ListaNombre);
            
            //Procedimiento para el metodo del arbol
            RESULT = temp;
        }
      :}
      |OTROS:a               {: RESULT = a; :}
;

OTROS ::= cadena:a
          {:
            //Procedimiento para el método Thompson
            NodoT t1 = new NodoT();
            NodoT t2 = new NodoT();
            t1.next1 = t2;
            t1.tran1 =  a ;
            
            NodoT Cabecera = t1;
            NodoT Salida = t2;
            ArrayList<NodoT>ListaNombre = new ArrayList<>();
            ListaNombre.add(t1);
            ListaNombre.add(t2);
            ArrayList<Object> temp = new ArrayList<>();
            temp.add(Cabecera);
            temp.add(Salida);
            temp.add(ListaNombre);
            RESULT = temp;
          :}

          |especial:a
          {:
            //Procedimiento para el método Thompson
            NodoT t1 = new NodoT();
            NodoT t2 = new NodoT();
            t1.next1 = t2;
            t1.tran1 = "\""+ "\\" + a + "\"";
            
            NodoT Cabecera = t1;
            NodoT Salida = t2;
            ArrayList<NodoT>ListaNombre = new ArrayList<>();
            ListaNombre.add(t1);
            ListaNombre.add(t2);
            ArrayList<Object> temp = new ArrayList<>();
            temp.add(Cabecera);
            temp.add(Salida);
            temp.add(ListaNombre);
            RESULT = temp;
          :}

          |letra:a
          {:
            //Procedimiento para el método Thompson
            NodoT t1 = new NodoT();
            NodoT t2 = new NodoT();
            t1.next1 = t2;
            t1.tran1 = "\"" + a + "\"";
            
            NodoT Cabecera = t1;
            NodoT Salida = t2;
            ArrayList<NodoT>ListaNombre = new ArrayList<>();
            ListaNombre.add(t1);
            ListaNombre.add(t2);
            ArrayList<Object> temp = new ArrayList<>();
            temp.add(Cabecera);
            temp.add(Salida);
            temp.add(ListaNombre);
            RESULT = temp;
          :}
          
          |digito:a
          {:
            //Procedimiento para el método Thompson
            NodoT t1 = new NodoT();
            NodoT t2 = new NodoT();
            t1.next1 = t2;
            t1.tran1 = "\"" + a + "\"";
            
            NodoT Cabecera = t1;
            NodoT Salida = t2;
            ArrayList<NodoT>ListaNombre = new ArrayList<>();
            ListaNombre.add(t1);
            ListaNombre.add(t2);
            ArrayList<Object> temp = new ArrayList<>();
            temp.add(Cabecera);
            temp.add(Salida);
            temp.add(ListaNombre);
            RESULT = temp;
          :}
;

BINARIO ::= concatenacion:a               {: RESULT = a; :}
            |or:a                         {: RESULT = a; :}
;

UNARIO  ::= kleene:a                      {: RESULT = a; :}
            |positiva:a                   {: RESULT = a; :}
            |cerouno:a                    {: RESULT = a; :}
;

/*--------------- Manejo de Validaciones -----------------------*/
VALIDAR ::= id dospuntos cadena puntocoma VALIDAR
            |id dospuntos cadena puntocoma
;